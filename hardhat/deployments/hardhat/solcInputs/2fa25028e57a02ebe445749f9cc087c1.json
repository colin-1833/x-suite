{
  "language": "Solidity",
  "sources": {
    "contracts/JoinX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IInviteContract {\n    function redeem(address receiver) external;\n}\n\ncontract InviteContract is IInviteContract {\n    IERC20 X_token_contract;\n    address creator;\n\n    constructor(address X_token_address) {\n        creator = msg.sender;\n        X_token_contract = IERC20(X_token_address);\n    }\n\n    /**\n    * @dev Throws if anyone but the creator contract calls\n    */\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Only the creator contract can do that\");\n        _;\n    }\n\n    /**\n    * @dev Sends the .01 $X to any specified address\n    */\n    function redeem(address receiver) external override onlyCreator() {\n        X_token_contract.transfer(receiver, X_token_contract.balanceOf(address(this)));\n    }\n}\n\nabstract contract IX {\n    mapping(address => bool) public allowlist;\n    mapping(address => bool) public invitationSpent;\n}\n\ncontract JoinX {\n    IERC20 X_token_contract;\n    address public X_token_address = address(0);\n    address public invite_holding_address = address(0);\n    address public seed_invite_sender = address(0);\n    uint256 public treasury_fee = 0;\n    address public treasurer = address(0);\n    address public treasury = address(0);\n    address next_treasury = address(0);\n    address next_treasurer = address(0);\n\n    constructor(\n        address _X_token_address, \n        address _treasurer, \n        address _treasury, \n        uint256 _treasury_fee\n    ) {\n        X_token_contract = IERC20(_X_token_address);\n        X_token_address = _X_token_address;\n        treasurer = _treasurer;\n        treasury = _treasury;\n        treasury_fee = _treasury_fee;\n    }\n    \n    /// Events\n\n    event JoinedX(address _member, address _invite_holding_address, uint256 _fee_paid);   \n    event SacrifiedSeedInvite(address sender, address _invite_holding_address);   \n    event ChangedTreasurer(address _old_treasurer, address _new_treasurer);\n    event ChangedTreasury(address _old_treasury, address _new_treasury);\n\n    /// Access Control Modifiers\n\n    /**\n    * @dev Throws when this contract has no seed invite to recycle\n    */\n    modifier seedInviteExists() {\n        require(address(0) != seed_invite_sender, \"No seed invite exists\");\n        _;\n    }\n\n    /**\n    * @dev Throws when the contract DOES have a seed invite to recycle\n    */\n    modifier seedInviteDoesNotExist() {\n        require(address(0) == seed_invite_sender, \"A seed invite already exists\");\n        _;\n    }\n\n    /**\n    * @dev Only the contract or person receiving the \n    */\n    modifier onlyTreasurer() {\n        require(msg.sender == treasurer, \"Only the treasury can do that\");\n        _;\n    }\n\n    /**\n    * @dev Throws if msg.sender never doesn't have at least .01 $X\n    */\n    modifier onlyWhenBalanceIsSufficient() {\n        require(X_token_contract.balanceOf(msg.sender) >= 1, \"You need at least .01 $X\");\n        _;\n    }\n\n    /**\n    * @dev Throws if msg.sender never set the minimum allowance\n    */\n    modifier onlyWhenAllowed() {\n        require(X_token_contract.allowance(msg.sender, address(this)) >= 1, \"This contract is not approved to transfer .01 $X\");\n        _;\n    }\n\n    /// Public Methods\n\n    /**\n    * @dev Stores the next treasury address for confirmation\n    */\n    function updateTreasuryAddress(address _next_treasury) external onlyTreasurer() {\n        require(address(0) != _next_treasury, \"Treasury address must not be empty\");\n\n        next_treasury = _next_treasury;\n    }\n\n    /**\n    * @dev Confirms and changes the treasury address\n    */\n    function confirmTreasuryAddress(address _treasury) external onlyTreasurer() {\n        require(_treasury == next_treasury, \"Wrong treasury address supplied\");\n        require(address(0) != _treasury, \"Treasury address must not be empty\");\n\n        emit ChangedTreasury(treasury, _treasury);\n        \n        treasury = _treasury;\n    }\n    \n    /**\n    * @dev Stores the next treasurer address for confirmation\n    */\n    function updateTreasurerAddress(address _next_treasurer) external onlyTreasurer() {\n        require(address(0) != _next_treasurer, \"Treasurer address must not be empty\");\n\n        next_treasurer = _next_treasurer;\n    }\n\n    /**\n    * @dev Confirms and changes the treasurer address\n    */\n    function confirmTreasurerAddress(address _treasurer) external onlyTreasurer() {\n        require(_treasurer == next_treasurer, \"Wrong treasurer address supplied\");\n        require(address(0) != _treasurer, \"Treasurer address must not be empty\");\n\n        emit ChangedTreasury(treasurer, _treasurer);\n\n        treasurer = _treasurer;\n    }\n\n    /**\n    * @dev Changes the fee paid out to the treasury\n    */\n    function updateTreasuryFee(uint256 _treasury_fee) external onlyTreasurer() {\n        require(_treasury_fee >= 0, \"Membership must be a non negative number\");\n\n        treasury_fee = _treasury_fee;\n    }\n\n    /**\n    * @dev Sacrifices sender's only X invite and locks it away where anyone can use it and recycle it\n    */\n    function sacrificeSeedInvite() external seedInviteDoesNotExist() onlyWhenAllowed() {\n        // Throw if the sender has already spent their invite\n        require(IX(X_token_address).invitationSpent(msg.sender) == false, \"You already spent your invite\");\n\n        // sender must have the minimal amount of $X\n        require(X_token_contract.balanceOf(msg.sender) >= 1, \"You need at least .01 $X\");\n\n        // store the invite holding address for use in join\n        invite_holding_address = address(new InviteContract(address(X_token_contract)));\n\n        // send .01 $X tokens to the contract created above\n        X_token_contract.transferFrom(msg.sender, invite_holding_address, 1);\n\n        seed_invite_sender = msg.sender;\n\n        emit SacrifiedSeedInvite(msg.sender, invite_holding_address);\n    }\n\n    /**\n    * @dev Anyone not yet invited to X can call this function, pay a small treasury fee, and then go out and buy X on various exchanges\n    */\n    function join() payable external seedInviteExists() onlyWhenAllowed() {\n        // Throw if the msg.value paid to the treasury is incorrect\n        require(treasury_fee == msg.value, \"Incorrect treasury fee supplied\");\n        \n        // Throw if the sender has already been invited into X\n        require(IX(X_token_address).allowlist(msg.sender) == false, \"You are already invited to X\");\n\n        // The holding contract sends the .01 $X to msg.sender, inviting msg.sender to X\n        IInviteContract(invite_holding_address).redeem(msg.sender);\n\n        // Store the invite holding address for use on next join\n        invite_holding_address = address(new InviteContract(address(X_token_contract)));\n\n        // send .01 $X tokens to the contract created above\n        X_token_contract.transferFrom(msg.sender, invite_holding_address, 1);\n\n        // send the treasury fee \n        (bool sent,) = treasury.call{ value: msg.value }(\"\");\n        require(sent, \"Failed to send fees to the treasury\");\n\n        emit JoinedX(msg.sender, invite_holding_address, msg.value);\n    }\n\n    /**\n    * @dev Getter to load address status in UI\n    */\n    function getInviteSpent(address _address) external view returns(bool) {\n        return IX(X_token_address).invitationSpent(_address);\n    }\n\n    /**\n    * @dev Getter to load address status in UI\n    */\n    function getAllowed(address _address) external view returns(bool) {\n        return IX(X_token_address).allowlist(_address);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}