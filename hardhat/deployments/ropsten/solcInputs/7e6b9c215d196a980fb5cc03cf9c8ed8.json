{
  "language": "Solidity",
  "sources": {
    "contracts/FakeX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Lightweight token modelled after UNI-LP:\n// https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\n// Adds:\n//   - An exposed `mint()` with minting role\n//   - An exposed `burn()`\n//   - ERC-3009 (`transferWithAuthorization()`)\ncontract FakeX is IERC20 {\n    // bytes32 private constant EIP712DOMAIN_HASH =\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // bytes32 private constant NAME_HASH = keccak256(\"X\")\n    bytes32 private constant NAME_HASH = 0x550c64a15031c3064454c19adc6243a6122c138a242eaa098da50bb114fc8d56;\n\n    // bytes32 private constant VERSION_HASH = keccak256(\"1\")\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    // bytes32 public constant PERMIT_TYPEHASH =\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    // keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n        0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    string public constant name = \"fX\";\n    string public constant symbol = \"fX\";\n    uint8 public constant decimals = 2;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n    // Token X specific\n    mapping(address => bool) public allowlist;\n    mapping(address => bool) public invitationSpent;\n    address public dropzero;\n\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event ChangeMinter(address indexed minter);\n\n    constructor() {\n        dropzero = msg.sender;\n    }\n\n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"X:INVALID_SIGNATURE\");\n    }\n\n    function mint(address to, uint256 value) external {\n        require(msg.sender == dropzero, \"MINT: ONLY_DROPZERO\");\n        _mint(to, value);\n        allowlist[to] = true;\n    }\n\n    function renounceMinter() external {\n        require(block.timestamp > 1637366400, \"AFTER 1637366400 (20th of November)\");\n        dropzero = address(0);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply + value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _addToAllowList(address from, address to) internal {\n        if (allowlist[to] == false && invitationSpent[from] == false) {\n            invitationSpent[from] = true;\n            allowlist[to] = true;\n        }\n    }\n\n    function _burn(address from, uint256 value) internal {\n        // Balance is implicitly checked with Solidity's underflow protection\n        balanceOf[from] = balanceOf[from] - value;\n        totalSupply = totalSupply - value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        require(to != address(this) && to != address(0), \"X:RECEIVER_IS_TOKEN_OR_ZERO\");\n        require(allowlist[from] == true, \"blockzerolabs.io/x/getInvite\");\n        _addToAllowList(from, to);\n        require(allowlist[to] == true, \"blockzerolabs.io/x/getInvite\");\n\n        // Balance is implicitly checked with Solidity's underflow protection\n        balanceOf[from] = balanceOf[from] - value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(from, to, value);\n    }\n\n    function getChainId() public view returns (uint256 chainId) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(EIP712DOMAIN_HASH, NAME_HASH, VERSION_HASH, getChainId(), address(this)));\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != type(uint256).max) {\n            // Allowance is implicitly checked with Solidity's underflow protection\n            allowance[from][msg.sender] = fromAllowance - value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"X:AUTH_EXPIRED\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner], deadline));\n        nonces[owner] = nonces[owner] + 1;\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp > validAfter, \"X:AUTH_NOT_YET_VALID\");\n        require(block.timestamp < validBefore, \"X:AUTH_EXPIRED\");\n        require(!authorizationState[from][nonce], \"X:AUTH_ALREADY_USED\");\n\n        bytes32 encodeData =\n            keccak256(\n                abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce)\n            );\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/JoinX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IInviteContract {\n    function redeem(address receiver) external;\n}\n\ncontract InviteContract is IInviteContract {\n    IERC20 X_token_contract;\n    address creator;\n\n    constructor(address X_token_address) {\n        creator = msg.sender;\n        X_token_contract = IERC20(X_token_address);\n    }\n\n    /**\n    * @dev Throws if anyone but the creator contract calls\n    */\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Only the creator contract can do that\");\n        _;\n    }\n\n    /**\n    * @dev Sends the .01 $X to any specified address\n    */\n    function redeem(address receiver) external override onlyCreator() {\n        X_token_contract.transfer(receiver, X_token_contract.balanceOf(address(this)));\n    }\n}\n\nabstract contract IX {\n    mapping(address => bool) public allowlist;\n    mapping(address => bool) public invitationSpent;\n}\n\ncontract JoinX {\n    IERC20 X_token_contract;\n    address public X_token_address = address(0);\n    address public invite_holding_address = address(0);\n    address public seed_invite_sender = address(0);\n    uint256 public treasury_fee = 0;\n    address public treasurer = address(0);\n    address public treasury = address(0);\n    address next_treasury = address(0);\n    address next_treasurer = address(0);\n\n    constructor(\n        address _X_token_address, \n        address _treasurer, \n        address _treasury, \n        uint256 _treasury_fee\n    ) {\n        X_token_contract = IERC20(_X_token_address);\n        X_token_address = _X_token_address;\n        treasurer = _treasurer;\n        treasury = _treasury;\n        treasury_fee = _treasury_fee;\n    }\n    \n    /// Events\n\n    event JoinedX(address _member, address _invite_holding_address, uint256 _fee_paid);   \n    event SacrifiedSeedInvite(address sender, address _invite_holding_address);   \n    event ChangedTreasurer(address _old_treasurer, address _new_treasurer);\n    event ChangedTreasury(address _old_treasury, address _new_treasury);\n\n    /// Access Control Modifiers\n\n    /**\n    * @dev Throws when this contract has no seed invite to recycle\n    */\n    modifier seedInviteExists() {\n        require(address(0) != seed_invite_sender, \"No seed invite exists\");\n        _;\n    }\n\n    /**\n    * @dev Throws when the contract DOES have a seed invite to recycle\n    */\n    modifier seedInviteDoesNotExist() {\n        require(address(0) == seed_invite_sender, \"A seed invite already exists\");\n        _;\n    }\n\n    /**\n    * @dev Only the contract or person receiving the \n    */\n    modifier onlyTreasurer() {\n        require(msg.sender == treasurer, \"Only the treasury can do that\");\n        _;\n    }\n\n    /**\n    * @dev Throws if msg.sender never doesn't have at least .01 $X\n    */\n    modifier onlyWhenBalanceIsSufficient() {\n        require(X_token_contract.balanceOf(msg.sender) >= 1, \"You need at least .01 $X\");\n        _;\n    }\n\n    /**\n    * @dev Throws if msg.sender never set the minimum allowance\n    */\n    modifier onlyWhenAllowed() {\n        require(X_token_contract.allowance(msg.sender, address(this)) >= 1, \"This contract is not approved to transfer .01 $X\");\n        _;\n    }\n\n    /// Public Methods\n\n    /**\n    * @dev Stores the next treasury address for confirmation\n    */\n    function updateTreasuryAddress(address _next_treasury) external onlyTreasurer() {\n        require(address(0) != _next_treasury, \"Treasury address must not be empty\");\n\n        next_treasury = _next_treasury;\n    }\n\n    /**\n    * @dev Confirms and changes the treasury address\n    */\n    function confirmTreasuryAddress(address _treasury) external onlyTreasurer() {\n        require(_treasury == next_treasury, \"Wrong treasury address supplied\");\n        require(address(0) != _treasury, \"Treasury address must not be empty\");\n\n        emit ChangedTreasury(treasury, _treasury);\n        \n        treasury = _treasury;\n    }\n    \n    /**\n    * @dev Stores the next treasurer address for confirmation\n    */\n    function updateTreasurerAddress(address _next_treasurer) external onlyTreasurer() {\n        require(address(0) != _next_treasurer, \"Treasurer address must not be empty\");\n\n        next_treasurer = _next_treasurer;\n    }\n\n    /**\n    * @dev Confirms and changes the treasurer address\n    */\n    function confirmTreasurerAddress(address _treasurer) external onlyTreasurer() {\n        require(_treasurer == next_treasurer, \"Wrong treasurer address supplied\");\n        require(address(0) != _treasurer, \"Treasurer address must not be empty\");\n\n        emit ChangedTreasury(treasurer, _treasurer);\n\n        treasurer = _treasurer;\n    }\n\n    /**\n    * @dev Changes the fee paid out to the treasury\n    */\n    function updateTreasuryFee(uint256 _treasury_fee) external onlyTreasurer() {\n        require(_treasury_fee >= 0, \"Membership must be a non negative number\");\n\n        treasury_fee = _treasury_fee;\n    }\n\n    /**\n    * @dev Sacrifices sender's only X invite and locks it away where anyone can use it and recycle it\n    */\n    function sacrificeSeedInvite() external seedInviteDoesNotExist() onlyWhenAllowed() {\n        // Throw if the sender has already spent their invite\n        require(IX(X_token_address).invitationSpent(msg.sender) == false, \"You already spent your invite\");\n\n        // sender must have the minimal amount of $X\n        require(X_token_contract.balanceOf(msg.sender) >= 1, \"You need at least .01 $X\");\n\n        // store the invite holding address for use in join\n        invite_holding_address = address(new InviteContract(address(X_token_contract)));\n\n        // send .01 $X tokens to the contract created above\n        X_token_contract.transferFrom(msg.sender, invite_holding_address, 1);\n\n        seed_invite_sender = msg.sender;\n\n        emit SacrifiedSeedInvite(msg.sender, invite_holding_address);\n    }\n\n    /**\n    * @dev Anyone not yet invited to X can call this function, pay a small treasury fee, and then go out and buy X on various exchanges\n    */\n    function join() payable external seedInviteExists() onlyWhenAllowed() {\n        // Throw if the msg.value paid to the treasury is incorrect\n        require(treasury_fee == msg.value, \"Incorrect treasury fee supplied\");\n        \n        // Throw if the sender has already been invited into X\n        require(IX(X_token_address).allowlist(msg.sender) == false, \"You are already invited to X\");\n\n        // The holding contract sends the .01 $X to msg.sender, inviting msg.sender to X\n        IInviteContract(invite_holding_address).redeem(msg.sender);\n\n        // Store the invite holding address for use on next join\n        invite_holding_address = address(new InviteContract(address(X_token_contract)));\n\n        // send .01 $X tokens to the contract created above\n        X_token_contract.transferFrom(msg.sender, invite_holding_address, 1);\n\n        // send the treasury fee \n        (bool sent,) = treasury.call{ value: msg.value }(\"\");\n        require(sent, \"Failed to send fees to the treasury\");\n\n        emit JoinedX(msg.sender, invite_holding_address, msg.value);\n    }\n\n    /**\n    * @dev Getter to load address status in UI\n    */\n    function getInviteSpent(address _address) external view returns(bool) {\n        return IX(X_token_address).allowlist(_address);\n    }\n\n    /**\n    * @dev Getter to load address status in UI\n    */\n    function getAllowed(address _address) external view returns(bool) {\n        return IX(X_token_address).invitationSpent(_address);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}